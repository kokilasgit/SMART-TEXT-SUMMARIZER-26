"""
SQLAlchemy ORM Models for Smart Text Summarizer
"""
from datetime import datetime
from flask_sqlalchemy import SQLAlchemy
from flask_login import UserMixin
from werkzeug.security import generate_password_hash, check_password_hash

db = SQLAlchemy()


class User(UserMixin, db.Model):
    """User model for authentication and profile"""
    _tablename_ = 'users'
    
    id = db.Column(db.Integer, primary_key=True)
    email = db.Column(db.String(120), unique=True, nullable=False, index=True)
    password_hash = db.Column(db.String(256), nullable=False)
    name = db.Column(db.String(100), nullable=False)
    # Role used for 'admin_required' access control decorator
    role = db.Column(db.String(20), default='user')
    # If False, user cannot login; used for soft deletion/deactivation
    is_active = db.Column(db.Boolean, default=True)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    last_login = db.Column(db.DateTime)
    
    # Relationships
    summaries = db.relationship('Summary', backref='user', lazy='dynamic')
    notifications = db.relationship('Notification', backref='user', lazy='dynamic')
    reset_tokens = db.relationship('PasswordResetToken', backref='user', lazy='dynamic')
    
    def set_password(self, password):
        """Hash and set password"""
        self.password_hash = generate_password_hash(password)
    
    def check_password(self, password):
        """Verify password"""
        return check_password_hash(self.password_hash, password)
    
    def is_admin(self):
        """Check if user is admin"""
        return self.role == 'admin'
    
    def get_summary_count(self):
        """Get total summaries generated by user"""
        return self.summaries.filter_by(is_deleted=False).count()
    
    def _repr_(self):
        return f'<User {self.email}>'


class Summary(db.Model):
    """Summary model for storing summarization history"""
    _tablename_ = 'summaries'
    
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False, index=True)
    input_text = db.Column(db.Text, nullable=False)
    summary_text = db.Column(db.Text, nullable=False)
    summary_length = db.Column(db.String(20), nullable=False)  # short, medium, long
    summary_type = db.Column(db.String(20), default='extractive')  # extractive, abstractive
    input_word_count = db.Column(db.Integer)
    summary_word_count = db.Column(db.Integer)
    created_at = db.Column(db.DateTime, default=datetime.utcnow, index=True)
    is_deleted = db.Column(db.Boolean, default=False)
    
    def get_preview(self, length=100):
        """Get a preview of the input text"""
        if len(self.input_text) <= length:
            return self.input_text
        return self.input_text[:length] + '...'
    
    def _repr_(self):
        return f'<Summary {self.id}>'


class Setting(db.Model):
    """Settings model for admin-configurable options"""
    _tablename_ = 'settings'
    
    id = db.Column(db.Integer, primary_key=True)
    key = db.Column(db.String(50), unique=True, nullable=False, index=True)
    value = db.Column(db.String(200), nullable=False)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    @staticmethod
    def get_value(key, default=None):
        """Get setting value by key"""
        setting = Setting.query.filter_by(key=key).first()
        return setting.value if setting else default
    
    @staticmethod
    def set_value(key, value):
        """Set or update setting value"""
        setting = Setting.query.filter_by(key=key).first()
        if setting:
            setting.value = str(value)
        else:
            setting = Setting(key=key, value=str(value))
            db.session.add(setting)
        db.session.commit()
        return setting
    
    def _repr_(self):
        return f'<Setting {self.key}={self.value}>'


class Notification(db.Model):
    """Notification model for user notifications"""
    _tablename_ = 'notifications'
    
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=True, index=True)  # null = broadcast
    title = db.Column(db.String(200), nullable=False)
    message = db.Column(db.Text, nullable=False)
    is_read = db.Column(db.Boolean, default=False)
    created_at = db.Column(db.DateTime, default=datetime.utcnow, index=True)
    
    def _repr_(self):
        return f'<Notification {self.id}>'


class PasswordResetToken(db.Model):
    """Password reset token model"""
    _tablename_ = 'password_reset_tokens'
    
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
    token = db.Column(db.String(100), unique=True, nullable=False, index=True)
    expires_at = db.Column(db.DateTime, nullable=False)
    is_used = db.Column(db.Boolean, default=False)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    
    def is_valid(self):
        """Check if token is valid (not expired and not used)"""
        return not self.is_used and datetime.utcnow() < self.expires_at
    
    def _repr_(self):
        return f'<PasswordResetToken {self.token[:8]}...>'